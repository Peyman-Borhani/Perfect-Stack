  
# [Perfect-Stack](#perfect-stack--i)  ðŸ› i
<br>  

### `A development guide` - `a precise DevTech Award` - `awesome-list of recommendations`  

- This document covers information for best practices, libs, tech stack, platforms, tools,...  
- Decide best options for your use-case, not a conformist who only follows popularity.  
- [To Contribute]() >> `add links` to items, `reason/prove` an obviously better option, `improve doc`.  

> <sub> * target users: <i> `developers`, `designers`, `researchers`, `students`, `startups`, `decision makers` </i> </sub>
<br>
  
  
## [`Shortcuts`](#shotcuts) >>
>  ### [ Awesome list](#awesome-list)  
>  ### [ Frameworks - more info/details](#frameworks-information)  
>  ### [ Extra information and discussion](#extra-information)  

***
<br>  

## [`To beginners and startups`](#to-beginners-and-startups)  

> Don't Adapt tech or make decisions just based on popularity hype...  
...instead, decide based on multiple factors, such as:  
[Pros]()/[Cons](), [Comparisons](), [Best fit for task](), [Problem solves]() [Rate/Popularity]()  
[Goals](): `work-type`: startup/job/personal __ `focus target`: start, scale, migrate, profit.  
[Impacts](): team, users, dev-cycle, stablity, milestone, cost, completeness...
<details> <summary>... expand topic â†´ </summary>  
Majority of developers adapted older popular tech/methods by the circumstances in past, either guided/dictated to use, by workplace/education requirements, or just due to common hype, popularity, senior advice..., or the 1st/only option in that category, in the past, but not the best choice now.  
This cycle repeats and non optimal tech get stuck in social, market, and job/edu systems, then if you adopt it, by the time you build your work on it, the tech might be near end of life, or bad/slow pace, as it holds to legacy patterns, and compatibility patches to make it work with ongoing needs of the users.  

Therefore instead of pop trends, make decisions based on facts, use whatever is best for the job, mostly if you're doing your own business or planning a `startup`,  deciding better tech/methods, results in productivity, efficiency and saves cost.  

Therefore If you're not forced or bound to a legacy eco-system or specific rules/conditions, do your research, compare options, and make decision which benefit in long-term.  
[*...extra pointers on this topic...>>*](#new-developer-or-decision-maker)  
</details>  

` Wish you good luck! `  
 ***
<br>

## Target Platforms  

[Native SDK]() `Android, iOS, embeded runtimes... if targeting specific device abilities or inclusive native functions of an embeded device, phones or a VR headset.`

[Web]() `if the development target is general, multi-platform, web/communication based, and not limited by vendor lock-in, then use the web platform, which has most use cases, most open and is cross-platform. It covers all platforms client, server, browser, mobile devices, cloud and desktop.`
  
[System]() `in case lower level control/privacy/system access is required, or direct Hardware/OS access and high performance at scale, then a server/workstation system/s plus a custom software stack (low/mid level programming languages, SDK, runtimes...) is more suitable.`

[Cloud]() `A complete or custom system solution on web/network. You subscribe to a managed virtual system, in different levels from VPS, API, Host... much features, managed/maintained. All pros, only cons: no physical control/access/privacy(unless self hosted)`  
  
### `Learning tips`
- Being a Dev is not easy, takes time, effort, practice and experience to gain practical skills, much to cover.  
- 1st learn the basics including the new updates. Ex:  for web >> Basics and new additions of JS, HTML, CSS.  
- Learn the main skill from Docs, or best resources, search for recent materials with high views/stats on youtube.  
- Group work, join friends, divide tasks/learning, share your findouts, practice as a team, is too much for one person.  
> ` Go to beginner guideline details `-> [Web-Dev guideline](#web-development-guideline)  
***
<br>  

# Awesome list  
<br>

## [AI](#ai)

### General Purpose  
- [Personal use/prompt](): Online: `Groq` - Local: `chat with RTX` -  `LM Studio`.  
- [Platform / API](): `Nvidia NIM`, `OpenAI`, `Clarifi(various)`, `Google`, `Microsoft`, `x.ai`.  
- [Browser/Runtime (client/user side)]():  `Web LLM` _ `Web-AI` _ `MLC-LLM` _ `Ai APIs/tools`.
<br>

### AGI - LLM models
- [Top Ranked]():  `Claude-3-Opus`, `GPT4-next`, `Grok`, `Llama-3-400B+ instruct`.  
- [Opensource](): `Phi3` _ `LLama3` _ `Mixtral` _ `Command R+` _ `DBRX`.  
- [Run Locally](): Mobile: `Phi3-mini-3.8B` _ Desktop: `Phi-3-small` - `Llama-3-8B instruct`.  

<sub> * `AGI` (Artificial General Intelligence) </sub>  
<br>

### Tools, Audio, Video...
- [Autonomous AI Agents]() _ MemGPT(long-term memory) _ SuperAGI _ MultiON _ AutoGPT  
- [Audio](): `Udio` text to music _ `PlayHT` or `ElevenLabs` text to speach _ `Deepgram ` speech to text  
- [Image](): `DALL-E`, `Stable Diffusion`, `Imagen`, `MidJourney`, [App](): `Adobe Firefly`
- [Visual input](): `Grok vision` - [Video creation](): `Sora ` most realistic videos by now.
- [Dev assist](): `Github Copilot` - `GPT-4 Chat/API` - [open-source](): `Open Devin` - `Devika`.  
<br>

Best youtube AI Channels:  [bycloud](https://www.youtube.com/@bycloudAI) - [Ai Jason](https://www.youtube.com/@AIJasonZ/videos) - [Matthew Berman](https://www.youtube.com/@matthew_berman/featured) 
<br>  

##### `About ` [Different AI generations](#about-ai---generations) >>  
##### *[Check AI Awesome list for more AI info/tools/applications, more details.](https://gist.github.com/Peyman-Borhani/57c3dd9ec0754c68d1dda3698b00f760)* >>  

---
<br>

## [Frameworks](#frameworks--)  >>
 - **`Mobile`**: Native device SDK......Open Web based (multi-platform): Socket, Tauri, Capacitor  
 - **`Desktop`**:  Tauri (Web App),  Deno executable(Web/CLI).  
 - **`Front-end`**: Svelte(best overall, best DX),  Vue(past populary=> more jobs), Solid(React replacement).  
 - **`Back-end`**: JS runtime-> Deno, Node.js/Bun - or specific platform, services, programming languages...  
 - **`Full-stack`**: Svelte-kit (true fullstack) - Astro(many frameworks) - Next/Nuxt (popular backends)  
 - **`Crossplatform`**: Socket runtime (Desktop, Mobile, P2P net/storage)  
 - **`Programming Languages`**:  Zig, Rust, Go, Mojo, Swift... (per use-case: Server/Backend, AI, Mobile).  
<br>  

### [UI](#ui-) >>  
**`Standard CSS`**:
>
 - when more control, precision and customization or zero dependency is required.   
 - new CSS standards solve much issuess developers had in the past.  
 - recommended for: small projects and teams, in any case you must master it to use libs effectively.  
 
 **`UI Lib/kit`** - *main advantages* >> less text instructions(+readability), uniform design model in team, faster development and prototyping, tools automation.  
 
 ### [UI categories](#ui-categories)
 
  - **`CSS utility framework`**:  
   > `UnoCSS` (short codes, presets, functions)  
   > `Lightening CSS` (tooling, optimizing, speed, new tech)  
  - **`UI structure`** (you do custom style): renderless, headless ui, Melt UI, Bits UI (Svelte).  
  - **`Minimal UI Libs`**: pico css, BeerCSS, DaisyUI(CSS lib).  
  - **`CSS toolkit`**:  UnoCSS - compiles other CSS frameworks into standard CSS.  
  - **`UI-Kits`**: Daisy UI(CSS) .... fully functional components:  Skeleton, flowbite...  
  - **`3D (WebGL/GPU)`**:  Spline, Babylone.js, Three.js(lower level), Threlte(Svelte+three), Unity Tiny.  
  
  
 ### [UI Recommendations](#ui-recommendations--reason) + `reason`:
 - `UnoCSS`  - best tool for presets. (code as other Libs yet it builds to standard CSS)  
 - `picoCSS` - best for predefined styling of standard HTML Tags.  
 - `DaisyUI` - best CSS UI lib you can get where JS is optional (pre UI kit).  
 - `Skeleton UI`- best UI components Kit for Svelte framework.  
 - `Agnostic UI`- various pros, in case it benefit your work.  
 - `BeerCSS` - better option in case you're into material design concept.  
<br>  

### [Cloud platforms](#cloud-platforms):  

- `Cloudflare`: most professional option, reliable, advanced network system and services.  
- `Hosting clouds`: used to host site/app, but now offer many cloud functions/solutions Ex: Vercel or Netlify  
- `Enterprise`: (more features+scale - extra cloud functions/services)  
> 1. Amazon AWS .... 2. Google/Firebase  .... 3. Azure (Microsoft)  

- #### [`Alternatives`](#alternatives): 
  - `Cloud/Server/CMS` -> Vercel -`simpler`: Supabase, Prismic -`Self host`: PocketBase, Sveltia.  
  - `Decentralised` -> Nostr, Bluesky/AT protocol. Social features, free, secure, anti-censorship.  
  - `Self hosted`: PocketBase ... `Basic/Dapp` -> Gun.js, free, encryption, distributed(web torrent).  
  - `Fullstack servers` + `free basic plan`: cyclic.sh(full options +S3 +DynamoDB) - railway.app (+postgreSQL)  


### [Database](#database):
- `Next-Gen`: Nostr, AT protocol, GunDB - decentrlized, secure, extra features(DB+SN/COMM).  
- `Performance`: cloud edge DBs `->` Turso(libSQL), Cloudflare/DenoDeploy(KV). `multi-model`: Redis + modules.  
- `Innovative `: Drizzle + Turso - EdgeDB - SurrealDB - Dgraph (graphQL+DX) - Vector DBs (AI use-cases).  
- `Open Source`: `libSQL` (fastest SQL on edge), `Arango DB` (multi-model) both can self host or cloud.    
- `Recommendations`:  
  > **` Nostr`** : decentralized, free, secure, privacy, best social/chat/communication protocol and DB store.  
  > **` Turso`** : edge networks,  using libSQL the open source fork of SQLite.  
  > **` Drizzle`**: the only ORM worth using, **`Reason`**: work with various DB formats without knowing them.  
  > **` EdgeDB`**: simple + you prefer EdgeQL + includes ORM/graphQL-ish model (no need for seperate ORM).  
  > **` SurrealDB`**: advanced, lots of DB models, features, customize and options.  
<br>  

### [API / Communication patterns](#api):

- `REST `... a client request data/information... from a server, which responds with state+data.  
- `GraphQL`. similar to rest but query a specific set of data, only effective if correctly queried(not less, not more).  
- `gRPC` ... binary data, prioritise performance, volume, and security. next generation of protobuffers.  
- `WebSocket` For real time, low latency applications.  
- `WebRTC / WebTorrent`  applications of distributed net, shared, p2p, serverless, save cost, user privacy/annonymity.  
- `ORM / DB communications type` for more control, relational behavior, custom schema and stored data.  

### [Other stuff](#other-stuff):
- **`Programming Languages`**:
  - **(Low level)**
    - **`Carbon`**(semi C++), `Zig`, **`Julia`**: LL Performance, High-Level syntax.  
    - **`Rust`**: WebASM std / Safe / Precise / System / Performance / Resources / Big Community, Support.  
    - **`Go`**: (Low/Med level): simple good syntax, well developed/maturity, good for backend.  
    - **`Nim`**(speed/semi python syntax). **`Mojo`**: (+semi-python, resources, AI, Devs).  
  - **(High level)**: **Platforms ecosystem**: `All: Web/JS`, `AI: Python`, `Mac/IOS: Swift`.  
  - **other good langs**: `Elixir`, `Haskel`, `C++`, `C#`.  
- **`Hosting`**: .. Vercel, Cloudflare Pages, Deno Deploy, Begin, Netlify.  
- **`Store/e-commerce`**: free open-source, best for developers: `Medusa` . best for non-devs: `Shopify`.  
- **`Static Site Generator`**:  Astro(all), Hugo(go), Hexo(js), Next(react), Nuxt(vue), MkDocs(py)  
- **`Content Management System`**:  Primo(svelte), Strapi, Ghost, Netlify CMS, Apostrophe, Factor(vue).
- **`Audio API`**: Tone.JS(free, all round audio API),  Twilio(Call communication, speech).  
- **`Dev/Repo` Platforms**: Github, Gitlab, Gitea (self-host), Stackblitz, Notion, Collab...  
- **`Dev tools`**:  CLI tools(GIT, bash, npm...), vite(bundler), vs-code + extensions, emmet...  
- **`Other stuff`**: find useful libs, online tools, AI tools, which help and improve DX.  
***
<br>  

## [Frameworks information](#frameworks-information)  
<br>  

### [Frontend](#frontend):  
 - **1. `Svelte`**: (Best overall), DX+, integrates and compiles to standard web, long term strategic choice.  
 - **2. `Solid`**: (Minimal), fast, efficient, reliable, fine tuned core structure, migration choice for react developers.  
 - **3. `Vue`**: (popular). ....  Angular / React / .net** (GG/FB/MS company platforms, Job offers/forced/required).  
<br>  

### [Backend](#backend):

#### JavaScript Runtimes:  
  - **`Deno`**: secure by default, lighter, faster, Wasm, better concept, +DX. *(recommended)*  
  - **`Node`**: most libs, support, popular eco-system. 
  - **`Bun`** : Node.js compatible but higher performance.  

#### Python eco-system:  jobs, popularity, AI libs, ease of usage, good for beginners, resources.  

<br>  

### [Fullstack](#fullstack): 
**`Sveltekit`**: complete yet custom scalable solution, flexible use of frontend + backend.  
> *Best web/app framework + DX, combined best practices and innovations in web ecosystem.*  

**`Node.js frameworks`**:  Next(Vercel, React), Nuxt(VUE), Astro(multi platform), JS(polka, koa).  
<br>  

### [Svelte framework pros](#svelte-framework-pros):  
**`Developer Experience`**: write less code, concentrate on your ideas, not development complexity.  
**`Standard`**: the code is compiled to standard JS. Fast/optimized, can be used anywhere, reusable.  
**`Less complexity`**: easier to read code, compiled and no online build process, no framework issues at runtime.  
> less Testing/Dependency issues:  unexpected reactions, conflicts, misunderstanding source of issues.  
> less Errors: due to not having runtime dependencies, or external factors except your own code.  

**`Less Cost`**: easier to read code of other devs => continue their work + less bugs + less testing + faster development.  
**`Smaller bundle size`** (Compiled), without virtual-dom and framework overhead...  

***
***
<br>  


# [Extra Information](#extra-information)  
<br>  

## **Web Development - about definitions**   
- `Front-end`: Web app/site, Develop/Design of client side. HTML5, CSS, JavaScript, PWA, frameworks, Web assembly...  
- `Back-end`: Processing/data on server network, host/cloud, centralized or distributed. SSR(Server Side Rendering). 
- `DevOps`: Admin, analytics, control, process, automation tools.  
- `Cloud`: online server platforms, you can subscribe to services: process, storage, resources, ready made functions.  
- `Cloud services`:  when you don't have a scalable server/resources. 2- require API/Apps/services from amazon, google,... 
- `Developer Experience`: (DX) satisfaction rate of developer, plus how empowering, practical, direct, and unambiguous it be.  
- `Correct development method` â‡’ simplify, reuse, secure, update, avoid complex dependencies/overhead.  
- `Software Engineering`:  use engineering principles and process-methods to approach the issue/task.  
- `Solution Architect`: a senior lead/engineer that evalutes an idea/goal/issue, then design, document and execute a structured plan while making many considerations.  
> A solution architect has some business insight/strategy and various technical knowledge/experience, using engineering principles, analytics,... design-pattern-process-methodology and some research experience.  
***


## **[Web development guideline](web-development-guideline):**  
 **1. Learn the base web standards** -> (HTML, CSS, Javascript) follow/practice tutorials. Make few apps.(ex: Todo)  
 **2. New web standards** -> ES6/next, new HTML, new CSS (grid,...)  practice/try what you learn.  
 **3. Update the previous apps you made**, using new things you learned. make a game and a blog site.  
 **4. Deploy**: learn how to host/deploy your site.  Host on cloudflare pages, deno deploy, begin, netlify, github pages,...  
 **5. Learn a Framework**s: Svelte. current best Dev Experience. Light, simple, fast, code compiles to standard JS (not limited).  
 **6. Learn only when required** learn extra stuff once you require(or predict) it. (Ex: DB, AI, specific tools/libs...)  
 **7. Learn Design**: Patterns, tools, UI/UX(user interface/experience). Concepts: visual clarity, visual effects, utility 1st.  
 **8. Responsive design**: native looks, any device, clear focus, usability/accessibility. CSS flex, grid...  
 **9. Backend**: 1. Sveltekit(if using svelte) ___ 2. Deno: new js-runtime replacement for Node.js by its creator.  
 **10.Personal** various experiences, use GIT, github, Make a portfolio site (show case). a social profile: Linkedin + twitter.  
 **11.Testing/Typing**: only if neccessary and: in large teams on complex projects with security risk or much new/junior/outsourced devs.  
 **12.Summary**: Be an expert in one field, pro on few more, know about the rest. Fullstack: Frontend + Backend + Eco-system + Experience.  


## **[About AI - Generations](about-ai---generations)**

`Past AI`: Machine Learning + Data/algorithms.  
Output results such as detection/decision/states... are made from a defined input processed by Machine Learning + Data science tools/patterns to extract meaningful data/states, using specific algorithms and models.  

`Pre/Current`: Generative AI, builds result from input data.  
- input can befrom single or multiple sources such as: files/DB/web/user prompt/system/parameters...  
- input/User describes a composed request: question/s, problem/s, statement prompt/s, data.  
- then Ai model process all to construct/expand/difuse/compose/conclude... Finally it generates the result based on request/objective.  

`Present`: Generative AGI. Is the same as above, but more accurate, matured and efficient.
- multi-modal, multi-tooling, larger models, improved data quality and training, higher performance hardware.  
- various methods and techniques used to improve results.
- increase precision/performance, reduce hallucination/mistakes, iterative pipelines to improve/abstract/clean/test data, verify, validate results.  

`Future Ai`: is a systemic AGI.  It creates custom composed advanced solutions, adding real-time autonomuos abilities.  
The past generation recognise, detect, compose a result, This new generation understands (input + general concept + you).  
- focused concepts and Results processed in realtime cycle, by a general purpose dynamic multi-model.  
- the output iterates/evolves based on all defined parameters, whatever interacts with it.  
- time-scalable, includes a history record, remember and relates, process past and current events, consider future.  
- optional autonomous act: triggers new events or impact external entities, based on various factors/parameters + input/sensor data.  

 ### [Work Tips](#work-tips):
 - Better: learn best new tech options, practice, freelance, get hired, build an idea startup team.
 - Easier: take a positive internship, learn, collab, you either get hired or improve portfolio/experience.  
 - Collaborate: Learn/Use collaboration tools/platforms like GitHub.  
 - Job: find a job or startup a new team.  Wish you the best.  

*** 
<br>  

## [The Web - status summary](#the-web-status-summary)
The web was originally made to communicate with text and data, it later evolved to present simple graphics and images.  
<details> <summary>...press to expand. </summary>  
Hardware advancements in performance and capacity, plus emerging smartphones and social networks caused web based online services go mainstream in network communications, it progressed fast and competes with native platforms.  
The sudden progress pace in contrast with the concept of keeping it backward compatible with legacy standards, caused some complexity and confusion in the last decade due to workarounds to support new features by vendor prefixes, various 3rd party libs, tools and frameworks to achieve demands of dev/user/market. The slow adoption of new trends was caused by issues with backward compatibility of existing sites and old systems while native mobile and desktop platforms had all breaking changes at once to support new hardware. By then 3rd party libs, prefixes and frameworks... were made to solve/patch the issue and provide features that didn't exist in web standards yet.  

Good news, the new web standards and innovations, improved the situation, furthermore Frameworks evolved and matured including new Web APIs to provide functionality and access to new technologies. Therefore with much flexibility, compatibility and openness, Web eco-system can now compete with native desktop and mobile platforms.  

Whenever learning something, learn latest stable standards and best practices, some of the old prefixes, 3rd party libs,... are not required anymore...(as explained above) unless is justified, mandatory or no alternatives. The recommended trends mentioned here were handpicked by checking reviews comparison, personal experiments, and by looking into new trends top professionals adopt.  
</details>
***
<br>  

### [New developer or decision maker?](#new-developer-or-decision-make?)
<details>
<summary> ...Details - Reasons and Pointers on choosing tech stack/methods... (press to expand)  
</summary>
- Avoid learning 6 ~ 10+ years old stuff if a better alternative is available.
 old tech was made for past era ecosystem, development model and HW/SW/issues.  

- Is still popular due to seniors who learned it in past when it was a valid option and using it at work for years, later new developers are forced to follow them. This process might repeat multiple times...   

- The old popular tech nature: ___ it works, is popular and has big community and resources, yet in time it becomes more complex, due to extensions, compatibility patches and conflict solving layers to make both the original and new syntax/tools/requirements work together...  Aside of that each time a new feature is added, this process might repeat, and the platform gets large, complex, multiple different revisions.(Ex: MS SDKs, .net framework,...)  

- Breaking changes and migration: ___ when a new feature that contradicts something in the system which can't be solved, the devs will decide to either give up on the feature, add extra flags/configs or make a breaking change, thus you must stay on old branch or learn + update your previous codes or totally migrate if is hopeless.  
  - Each time a breaking change shows up, you might need to repeat this process. this makes multiple dev branches in a company if the team can't / won't follow.  

- Prevent Issues:  an old legacy target which depends on layers of other legacy tech, will encounter conflicts, compatibility, deprecated dependencies, which will cost time + resources + man power to solve them. 

- Low level coding is not affected much by the mentioned issues. they rarely change, and if so, is about new features, compatibility and stability.  

- Unnessecary overhead: as old devs retire,  new ones might add extra layers of abstraction instead of updating the original code, these issues cause: extra complexity, overhead, extra cost in long-term, Large number/size of files, large developer teams, or slow working pace,...

</details>
***
<br>  
